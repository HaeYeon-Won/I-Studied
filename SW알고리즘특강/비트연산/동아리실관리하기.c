/*
삼성초등학교에는 영준, 준환, 동한, 하니 이렇게 네 명이 프로그래밍 동아리에 속해있다. 부원 네 명의 이름을 편의상 A, B, C, D라고 하자.

앞으로 N일간의 활동 일정을 정해야 한다.

각 부원은 하루의 활동에 참여를 할지 하지 않을지를 정해야 하며, 어떤 부원이 참여하는지의 경우의 수는 하루에 총 16가지이다.

그런데 아무도 활동에 참여하지 않으면 동아리가 폐부 될 수 있으므로 아무도 참여를 하지 않아서는 곤란하다.

즉 실제로는 15가지 경우가 있다.

동아리 실을 여는 열쇠는 하나밖에 없고 활동이 끝나면 동아리 실을 잠가야 하기 때문에 문을 열어주기 위해 열쇠를 가진 사람은 무조건 활동에 참여해야 한다.

오늘 활동에 참여하는 사람 중에 내일 활동에도 참여하는 사람이 있다면 열쇠를 넘겨줄 수 있다.

첫 번째 날에는 A가 열쇠를 가지고 있다.

모든 활동이 끝난 다음에는 열쇠를 누가 가지고 있어도 상관이 없다.


또한 N일 동안 각 날마다 활동의 책임자가 있어서 이 책임자는 무조건 활동에 참여해야 한다.

N일 동안의 동아리 활동을 할 수 있는 경우의 수를 출력하는 프로그램을 작성하라.

(열쇠를 누구에게 넘겨주는지는 중요하지 않고 어떤 사람이 활동을 하는지 안 하는지에 따라 경우의 수를 세어야 한다.)

예를 들어 동아리실 담당자가 첫날에는 B, 둘째 날 C라고 해보자.

위의 그림에서 가능한 경우에는 1일차와 2일차에 A가 열쇠를 전달해 주면 된다.

하지만 불가능 한 경우에는 1일차 있었던 사람이 2일차에 아무도 없기 때문에 동아리 실을 유지할 수 없게 된다.
 

[입력]

첫 번째 줄에 테스트 케이스의 수 T가 주어진다.

각 테스트 케이스마다 길이 10,000 이하인 하나의 문자열이 주어진다. 이 문자열은 A, B, C, D로 이루어져 있으며, i번째 문자는 i번째 날의 책임자가 누구인지를 나타낸다.


[출력]
각 테스트 케이스마다 N일 동안의 동아리 활동을 할 수 있는 경우의 수를 출력하는 프로그램을 작성하라.

이 수는 너무 커질 수 있으므로 1,000,000,007로 나눈 나머지를 출력한다.
 

입력
2
BC
ADCBBACDCBCBACBDCABDCBA	 

출력
#1 29
#2 88253169	 
*/

#include<iostream>
#include<string>
#include<cstring>
#define MOD 1000000007;
using namespace std;
int dp[10000][16];

int solution(string data)
{
	int result = 0;

	//첫번째 날 -> A와 필수로 참여해야하는 사람은 무조건 참가해야함
	int attendant = 1 << (data[0] - 'A'); //1일차에 필수적으로 참여해야하는 인원
	for (int i = 1; i < 16; i++) //동아리 참석 가능한 경우 -> 0001 ~1111
	{
		if ((attendant & i) && (1&i)) //A와 필수 참여자 모두 참가한 경우
		{
			dp[0][i] = 1; //첫날 참석 가능한 경우
		}
	}

	//두번째 날 부터
	for (int i = 1; i < data.length(); i++) //시간
	{
		attendant = 1 << (data[i] - 'A'); 
		for (int j = 1; j < 16; j++)
		{
			if (dp[i - 1][j] != 0) //전날이 존재 하는 경우 -> 만약 전날이 불가능한 경우라면 필수 참여자의 미참여 혹은 키 전달 불가능한 경우이므로 pass
			{
				for (int k = 1; k < 16; k++)
				{
					if ((attendant & k) && (j & k)) //오늘 필수 참여자가 참여해야하고(attendant & k), 전날 참여한 사람(키 전달자)이 참여해야함(j & k)
					{
						dp[i][k] += dp[i - 1][j]; //현재 일로 이어질 수 있는 전날정보를 현재 일의 경우의 수에 더해준다
						dp[i][k] %= MOD;//범위 안벗어 나게 처리
					}
				}
			}
		}
	}
	for (int i = 1; i < 16; i++)
	{
		result = (result + dp[data.length()-1][i]) % MOD; //가능한 총 경우의 수
	}

	return result;
}

int main(void)
{
	int TC;
	cin >> TC;
	for (int i = 1; i < TC + 1; i++)
	{
		memset(dp, 0, sizeof(dp));
		string data;
		cin >> data;
		int result = solution(data);
		cout << "#" << i << " " << result << "\n";
	}
	return 0;
}
